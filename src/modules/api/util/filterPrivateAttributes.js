'use strict';

var _ = require('lodash');


/**
 * Filter some entity 'private' attributes from the output
 * @param  {Model} entity some model
 * @param  {Object} data  the JSON generated by the controller with the entities data
 * @return {Object}       a copy of the original JSON, without the private atributes
 */
var filterPrivateAttributes = function(entity, data) {
  var privateAttrs = entity.privateAttrs;

  if(data && privateAttrs && privateAttrs.length) {
    if(_.isArray(data)) {
      data = data.map(function(node) {
        return filterNode(node, privateAttrs);
      });
    } else {
      data = filterNode(data, privateAttrs);
    }
  }

  return data;
};


/**
 * Filter some nested node (the output can be composed by a single node or an array of them)
 * @param  {Object} node  The node to filter
 * @param  {Arrau} attrs  Attributes to remove
 * @return {Object}
 */
var filterNode = function(node, attrs) {

  var
    attrFilters     = [],
    relationFilters = [];

  attrs.forEach(function(f) {
    // The filters can be simple strings, denoting node attributes,
    // or something like `comments[private=true]`, used on the relations.
    let parsed = /(\w+)(?:\[(\w+)(?:\=(\w+))?\])?/.exec(f);

    if(!parsed[2]) {
      attrFilters.push(f);
    } else {
      relationFilters.push({
        attr: parsed[1],
        key:  parsed[2],
        val:  parsed[3]
      });
    }
  });

  var filtered = _.clone(node);

  filtered = _.omit(filtered, attrFilters);

  relationFilters.forEach(function(f) {
    let
      nestedNode     = filtered[f.attr] || {},
      nestedNodeMeta = nestedNode.meta,
      nestedNodeData = nestedNode.data;

    if(nestedNodeData) {
      if(_.isArray(nestedNodeData)) {

        let newData = _.compact(nestedNodeData.map(function(n) {
          return filterNestedNode(n, f);
        }));

        filtered[f.attr].data = newData;

      } else {
        filtered[f.attr].data = filterNestedNode(nestedNodeData, f);
      }
    }
  });

  return filtered;
};


/**
 * Filter for nested nodes
 * @return {Mixed} if the filter does not have a value, it will return a copy of
 *                 the original node without the filter key.
 *                 If the filter has a value, it will return the node or false if
 *                 the filter value matches the node value.
 */
var filterNestedNode = function(node, filter) {
  if(_.isEmpty(filter.val)) {
    return _.omit(node, filter.attr);
  } else {
    var val = filter.val;

    try {
      val = JSON.parse(val);
    } catch(e) {}

    return node[filter.key] !== val ? node : false;
  }
};



module.exports = filterPrivateAttributes;

module.exports._filterNode       = filterNode;
module.exports._filterNestedNode = filterNestedNode;
